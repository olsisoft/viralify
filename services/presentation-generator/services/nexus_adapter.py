"""
NEXUS Adapter Service

Integrates NEXUS Engine for pedagogical code generation in presentations.
Replaces basic code generation with multi-agent orchestrated code.
"""

import os
import asyncio
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
import httpx
import logging

logger = logging.getLogger(__name__)


@dataclass
class NexusCodeSegment:
    """A code segment generated by NEXUS"""
    id: str
    filename: str
    code: str
    language: str
    component_type: str
    explanation: str
    key_concepts: List[str]
    common_mistakes: List[str]
    narration_script: str
    duration_seconds: int
    display_order: int


@dataclass
class NexusGenerationResult:
    """Result from NEXUS code generation"""
    request_id: str
    project_name: str
    language: str
    framework: str
    code_segments: List[NexusCodeSegment]
    total_duration_seconds: int
    total_lines_of_code: int
    generation_time_ms: int
    sync_metadata: Dict[str, Any]


class NexusAdapterService:
    """
    Adapter for communicating with NEXUS Engine microservice.

    Used by presentation-generator to generate pedagogical code
    for CODE and CODE_DEMO slides.
    """

    def __init__(self, nexus_url: Optional[str] = None):
        self.nexus_url = nexus_url or os.getenv("NEXUS_ENGINE_URL", "http://nexus-engine:8009")
        self.timeout = httpx.Timeout(300.0, connect=10.0)  # 5 min for generation
        self._client: Optional[httpx.AsyncClient] = None

    async def _get_client(self) -> httpx.AsyncClient:
        """Get or create HTTP client"""
        if self._client is None:
            self._client = httpx.AsyncClient(timeout=self.timeout)
        return self._client

    async def close(self):
        """Close the HTTP client"""
        if self._client:
            await self._client.aclose()
            self._client = None

    async def is_available(self) -> bool:
        """Check if NEXUS engine is available"""
        try:
            client = await self._get_client()
            print(f"[NEXUS] Checking availability at {self.nexus_url}/health", flush=True)
            response = await client.get(f"{self.nexus_url}/health", timeout=10.0)
            if response.status_code == 200:
                data = response.json()
                status = data.get("status")
                print(f"[NEXUS] Health check: status={status}", flush=True)
                return status in ["healthy", "degraded"]
            print(f"[NEXUS] Health check failed: HTTP {response.status_code}", flush=True)
            return False
        except httpx.ConnectError as e:
            print(f"[NEXUS] Connection error (is nexus-engine running?): {e}", flush=True)
            logger.warning(f"NEXUS engine not available: {e}")
            return False
        except httpx.TimeoutException as e:
            print(f"[NEXUS] Timeout connecting to {self.nexus_url}: {e}", flush=True)
            logger.warning(f"NEXUS engine timeout: {e}")
            return False
        except Exception as e:
            print(f"[NEXUS] Unexpected error: {type(e).__name__}: {e}", flush=True)
            logger.warning(f"NEXUS engine not available: {e}")
            return False

    async def generate_code(
        self,
        project_description: str,
        lesson_context: str = "",
        skill_level: str = "intermediate",
        language: str = "python",
        target_audience: str = "student",
        verbosity: str = "standard",
        allocated_time_seconds: int = 300,
        max_segments: int = 10,
        show_mistakes: bool = True,
        show_evolution: bool = False,
    ) -> NexusGenerationResult:
        """
        Generate pedagogical code using NEXUS Engine.

        This is a synchronous call that waits for generation to complete.
        Use for smaller projects or when immediate response is needed.

        Args:
            project_description: Description of the project/code to generate
            lesson_context: Context of the lesson (e.g., "Module 3: Backend Architecture")
            skill_level: beginner, intermediate, advanced, expert
            language: Programming language (python, javascript, etc.)
            target_audience: developer, architect, student, lead
            verbosity: minimal, standard, verbose, production
            allocated_time_seconds: Time budget for the code explanation
            max_segments: Maximum code segments to generate
            show_mistakes: Include common mistakes to avoid
            show_evolution: Show progressive versions (v1 -> v2 -> v3)

        Returns:
            NexusGenerationResult with all generated code segments
        """
        client = await self._get_client()

        request_data = {
            "project_description": project_description,
            "lesson_context": lesson_context,
            "skill_level": skill_level,
            "language": language,
            "target_audience": target_audience,
            "verbosity": verbosity,
            "allocated_time_seconds": allocated_time_seconds,
            "max_segments": max_segments,
            "show_mistakes": show_mistakes,
            "show_evolution": show_evolution,
        }

        logger.info(f"[NEXUS] Generating code for: {project_description[:50]}...")

        try:
            response = await client.post(
                f"{self.nexus_url}/api/v1/nexus/generate-sync",
                json=request_data,
            )
            response.raise_for_status()
            data = response.json()

            # Convert to dataclass
            segments = [
                NexusCodeSegment(
                    id=seg["id"],
                    filename=seg["filename"],
                    code=seg["code"],
                    language=seg["language"],
                    component_type=seg["component_type"],
                    explanation=seg["explanation"],
                    key_concepts=seg["key_concepts"],
                    common_mistakes=seg["common_mistakes"],
                    narration_script=seg["narration_script"],
                    duration_seconds=seg["duration_seconds"],
                    display_order=seg["display_order"],
                )
                for seg in data.get("code_segments", [])
            ]

            result = NexusGenerationResult(
                request_id=data["request_id"],
                project_name=data["project_name"],
                language=data["language"],
                framework=data["framework"],
                code_segments=segments,
                total_duration_seconds=data["total_duration_seconds"],
                total_lines_of_code=data["total_lines_of_code"],
                generation_time_ms=data["generation_time_ms"],
                sync_metadata=data.get("sync_metadata", {}),
            )

            logger.info(
                f"[NEXUS] Generated {len(segments)} segments, "
                f"{result.total_lines_of_code} LOC in {result.generation_time_ms}ms"
            )

            return result

        except httpx.HTTPStatusError as e:
            logger.error(f"[NEXUS] HTTP error: {e.response.status_code} - {e.response.text}")
            raise
        except Exception as e:
            logger.error(f"[NEXUS] Generation failed: {e}")
            raise

    async def generate_code_async(
        self,
        project_description: str,
        **kwargs
    ) -> str:
        """
        Start async code generation and return job ID.

        Use get_job_status() to poll for completion.

        Returns:
            Job ID for tracking progress
        """
        client = await self._get_client()

        request_data = {
            "project_description": project_description,
            **kwargs
        }

        response = await client.post(
            f"{self.nexus_url}/api/v1/nexus/generate",
            json=request_data,
        )
        response.raise_for_status()
        data = response.json()

        return data["job_id"]

    async def get_job_status(self, job_id: str) -> Dict[str, Any]:
        """
        Get the status of an async generation job.

        Returns:
            Dict with status, progress, stage, message, and result (if completed)
        """
        client = await self._get_client()

        response = await client.get(f"{self.nexus_url}/api/v1/nexus/jobs/{job_id}")
        response.raise_for_status()

        return response.json()

    async def wait_for_completion(
        self,
        job_id: str,
        poll_interval: float = 2.0,
        max_wait_seconds: float = 600.0,
    ) -> NexusGenerationResult:
        """
        Wait for an async job to complete.

        Args:
            job_id: Job ID from generate_code_async
            poll_interval: Seconds between status checks
            max_wait_seconds: Maximum time to wait

        Returns:
            NexusGenerationResult when completed
        """
        elapsed = 0.0

        while elapsed < max_wait_seconds:
            status = await self.get_job_status(job_id)

            if status["status"] == "completed":
                result_data = status["result"]

                segments = [
                    NexusCodeSegment(
                        id=seg["id"],
                        filename=seg["filename"],
                        code=seg["code"],
                        language=seg["language"],
                        component_type=seg["component_type"],
                        explanation=seg["explanation"],
                        key_concepts=seg["key_concepts"],
                        common_mistakes=seg["common_mistakes"],
                        narration_script=seg["narration_script"],
                        duration_seconds=seg["duration_seconds"],
                        display_order=seg["display_order"],
                    )
                    for seg in result_data.get("code_segments", [])
                ]

                return NexusGenerationResult(
                    request_id=result_data["request_id"],
                    project_name=result_data["project_name"],
                    language=result_data["language"],
                    framework=result_data["framework"],
                    code_segments=segments,
                    total_duration_seconds=result_data["total_duration_seconds"],
                    total_lines_of_code=result_data["total_lines_of_code"],
                    generation_time_ms=result_data["generation_time_ms"],
                    sync_metadata=result_data.get("sync_metadata", {}),
                )

            elif status["status"] == "failed":
                raise RuntimeError(f"NEXUS job failed: {status.get('error', 'Unknown error')}")

            await asyncio.sleep(poll_interval)
            elapsed += poll_interval

        raise TimeoutError(f"NEXUS job {job_id} timed out after {max_wait_seconds}s")


# Singleton instance
_nexus_adapter: Optional[NexusAdapterService] = None


def get_nexus_adapter() -> NexusAdapterService:
    """Get or create the NEXUS adapter singleton"""
    global _nexus_adapter
    if _nexus_adapter is None:
        _nexus_adapter = NexusAdapterService()
    return _nexus_adapter
